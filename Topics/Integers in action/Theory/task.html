<h2>Integers in action</h2>
<h5 id="int-and-long-integer-types">Int and long integer types</h5><p>Programmers often use integer numbers with their programs. As you may recall, Kotlin has several integer types. The most popular are <code class="language-kotlin">Int</code> (32 bits) and <code class="language-kotlin">Long</code> (64 bits). You can perform all types of arithmetic operations (<code class="language-kotlin">+</code>, <code class="language-kotlin">-</code>, <code class="language-kotlin">*</code>, <code class="language-kotlin">/</code>, <code class="language-kotlin">%</code>) with variables of these types. Let's take a look at several examples.</p><pre><code class="language-kotlin">val two = 2  // Int
val ten = 10 // Int

val twelve = two + ten // 12
val eight = ten - two  // 8
val twenty = two * ten // 20
val five = ten / two   // 5
val zero = ten % two   // 0, no remainder </code></pre><p>You know what these operations do. <code class="language-kotlin">Long</code> type integers support all these operations as well. To declare a variable of the <code class="language-kotlin">Long</code> type, you may choose one of these ways:</p><pre><code class="language-kotlin">val longNumber1 = 1_000_000_000_000_000
val longNumber2: Long = 1_000_000
val longNumber3 = 1000L

val result = longNumber1 + longNumber2 - longNumber3
println(result) // 1000000000999000</code></pre><p>The <code class="language-kotlin">longNumber1</code> value is of the <code class="language-kotlin">Long</code> type because it is greater than the possible value of the <code class="language-kotlin">Int</code> type. The <code class="language-kotlin">longNumber2</code> value is also <code class="language-kotlin">Long</code> because we have specified the type. The <code class="language-kotlin">longNumber3</code> value is <code class="language-kotlin">Long</code> because we have tagged the value with the suffix <code class="language-kotlin">L</code> (<code class="language-kotlin">Long</code>). The <code class="language-kotlin">result</code> is <code class="language-kotlin">Long</code>, as it is the sum of three <code class="language-kotlin">Long</code> integers.</p><p><strong>Tip:</strong> Use <code class="language-kotlin">Long</code> integers only when it is absolutely necessary (for example, to process large values).</p><p> </p><p>See the underscores <code class="language-kotlin">_</code> in the example above? In Kotlin, you can use underscores to improve the readability of a number. We can group digits with them. Underscores can't be placed before or after a number, but they can be placed inside a number between its digits, even in a row.</p><p> </p><h5 id="reading-numbers-from-the-standard-input">Reading numbers from the standard input</h5><p>To solve a problem, you generally need to read data from the input, process it, and output the result. For example, this program reads two numbers from the standard input, performs addition, and outputs the sum.</p><pre><code class="language-kotlin">fun main() {
    val a = readln().toInt()
    val b = readln().toInt()

    val sum = a + b

    println(sum)
}</code></pre><p>The <code class="language-kotlin">readln()</code> part is responsible for reading data. It works for positive, negative, and zero numbers because the <code class="language-kotlin">Int</code> type supports all of them.</p><p>If we know that input numbers can be large, we can read <code class="language-kotlin">Longs</code> instead of <code class="language-kotlin">Ints</code>:</p><pre><code class="language-kotlin">val a = readln().toLong()
val b = readln().toLong()</code></pre><p>After that, we don't need to change anything.</p><h5 id="unsigned-integers">Unsigned integers</h5><p>We already know that all integer types in Kotlin — <code class="language-kotlin">Int</code>, <code class="language-kotlin">Long</code>, <code class="language-kotlin">Byte</code>, and <code class="language-kotlin">Short</code> can be both positive and negative. In addition to all these integer types, Kotlin provides the ability to create <strong>unsigned</strong> integers – integers that can contain only non-negative values.</p><p>Kotlin provides the following unsigned types:</p><table border="1" cellpadding="1" cellspacing="1"><tbody><tr><td><p><strong>Type</strong></p></td><td><p><strong>Description</strong></p></td></tr><tr><td><p><code class="language-kotlin">UByte</code></p></td><td><p>an unsigned 8-bit integer, ranges from 0 to 255</p></td></tr><tr><td><p><code class="language-kotlin">UShort</code></p></td><td><p>an unsigned 16-bit integer, ranges from 0 to 65535</p></td></tr><tr><td><p><code class="language-kotlin">UInt</code></p></td><td><p>an unsigned 32-bit integer, ranges from 0 to 4 294 967 295 (2^32-1)</p></td></tr><tr><td><p><code class="language-kotlin">ULong</code></p></td><td><p>an unsigned 64-bit integer, ranges from 0 to 18 446 744 073 709 551 615 (2^64-1)</p></td></tr></tbody></table><p>Unsigned numbers are created in the same way as any others. In order to indicate that you are creating an unsigned number, you need to add the suffix "<code class="language-kotlin">u</code>" or "<code class="language-kotlin">U</code>" to it.</p><pre><code class="language-kotlin">val uByte: UByte = 5u
val uShort: UShort = 10U</code></pre><p>In this example, we create variables of specified types. But, if you don't indicate the type directly, then the compiler will use <code class="language-kotlin">UInt</code> or <code class="language-kotlin">ULong</code> depending on the size of the literal:</p><pre><code class="language-kotlin">val smallSize = 100u // UInt by default
val bigSize = 5_000_000_000u // ULong because the number doesn't fit in UInt</code></pre><p>There is also a special suffix "<code class="language-kotlin">uL</code>" (or "<code class="language-kotlin">UL</code>"). If you tag a number with this suffix, then an <code class="language-kotlin">ULong</code> will be created regardless of the size of the number:</p><pre><code class="language-kotlin">val smallLong = 10uL // ULong because it is marked with "uL"</code></pre><h5 id="data-type-overflow">Data type overflow</h5><p>All arithmetic operations for signed types are possible with their unsigned counterparts, except for the unary minus operation.</p><p>Let's look at the results of the following code:</p><pre><code class="language-kotlin">// MAX_VALUE: Int = 2147483647
var d: Int = 2147483647
d += 1
println(d) // -2147483648
</code></pre><p>An unexpected result. A similar situation is called data type overflow. Note that these are details and it is not necessary to figure it out now. To understand what happened, imagine an empty glass into which water is poured. When the glass is full, the water overflows over the edges. The same situation happens with variables. When the variable value is close to the boundary value, there is a risk of a situation where the resulting value does not fit into the allocated memory for the variable. Overflow of the variable type leads to data loss, unexpected behavior of the program, etc.</p><p>Let's figure out why the overflow occurred in our example. Variables of type <code class="language-kotlin">Int</code> have a maximum value of <code class="language-kotlin">MAX_VALUE: Int = 2147483647</code>. Let's see what happens when the number increases more than the maximum value. We remember that the computer works only 1 and 0. For a computer, the number 2147483647 is as follows:</p><pre><code class="language-kotlin">2147483647 = 01111111111111111111111111111111</code></pre><p>When we add 1 to this number, we get the following result:</p><pre><code class="language-kotlin">10000000000000000000000000000000 = -2147483648</code></pre><p>All magic occurs when the left bit of the number takes the value 1 and the number takes a negative value. You can study this topic in more detail <a href="https://hyperskill.org/learn/step/19917" rel="noopener noreferrer nofollow" target="_blank">here</a>, <a href="https://hyperskill.org/learn/step/5745" rel="noopener noreferrer nofollow" target="_blank">here</a>, and <a href="https://hyperskill.org/learn/step/5753" rel="noopener noreferrer nofollow" target="_blank">here</a>. Now we can say when we have reached the maximum value of the data type, the next value after the maximum will be the minimum value of the type. And so in a circle.</p><p>Let's look at another example:</p><pre><code class="language-kotlin">val c: Long = 1_000_000_000_000_000
println(c.toInt())</code></pre><p>And the result of the code execution:</p><pre><code class="language-no-highlight">-1530494976</code></pre><p>In this example, we tried to put the <code class="language-kotlin">Long</code> variable in <code class="language-kotlin">Int</code>. A cut occurred, the lower bits of the number remained and the higher bits were lost, the result is again unpredictable. Look at how this happens:</p><p style="text-align: center;"><img alt="Long variable in Int" height="99" src="https://ucarecdn.com/653efe3f-d247-4795-a1f2-9651bd5ac265/" width="488"/></p><p>It is important to remember the following points:<br/>- data type overflow errors are the programmer's errors;<br/>- program behavior in the case of data type overflow is unpredictable;<br/>- the compiler will not say that a type overflow is possible, so you need to correctly select data types for variables, as well as carefully monitor the transformation of data types.</p><h5 id="conclusion">Conclusion</h5><p>In this topic, we have covered two basic Kotlin integer types — <code class="language-kotlin">Long</code> and <code class="language-kotlin">Int</code>, and learned how to read data from the input. We've also learned what unsigned integer types are. Now you have enough skills to write programs that process data. You may use the template above to solve the code problems in this topic. Remember to give meaningful names to your variables, as it really helps.</p>
